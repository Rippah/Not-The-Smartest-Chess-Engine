import chess
from copy import deepcopy
import random
import chess.polyglot
import chess_display

reader = chess.polyglot.open_reader('Elo2400.bin')

def random_movement(BOARD):
    return random.choice(list(BOARD.legal_moves))

point_values = {
            'p' : -1,
            'n' : -3,
            'b' : -3,
            'r' : -5,
            'q' : -9,
            'k' :  0,
            'P' :  1,
            'N' :  3,
            'B' :  3,
            'R' :  5,
            'Q' :  9,
            'K' :  0
               }

center_squares = {chess.E4, chess.E5, chess.D4, chess.D5}
center_value = 0.5

def evaluate_board(BOARD):
    points = 0
    pieces = BOARD.piece_map()
    for key in pieces:
        piece_value = point_values[str(pieces[key])]
        points += piece_value
        
    return points

def evaluate_space(BOARD):
    space = len(list(BOARD.legal_moves))
    value = (space / (20 + space))

    if BOARD.turn == True:
        return value
    else:
        return -value
    
def evaluate_center_control(BOARD):
    center_control = 0
    for square in center_squares:
        piece = BOARD.piece_at(square)
        if piece is not None:
            if piece.color == BOARD.turn:
                center_control += center_value
            else:
                center_control -= center_value

    return center_control

def evaluate_piece_safety(BOARD, piece):
    threats = BOARD.attackers(not BOARD.turn, piece)
    if threats:
        threat_value = -0.05 * point_values[str(piece)]
        return threat_value if threat_value != 0 else -2
    
    for move in BOARD.legal_moves:
        if move.from_square == piece and move.to_square in threats:
            threat_value = -1.25 * point_values[str(piece)]
            return threat_value if threat_value != 0 else -20

    return 0

def min_max_movement_depth_N_alphabeta_iterative(BOARD, _, alpha, beta):
    opening_move = reader.get(BOARD)

    if opening_move is not None:
        return opening_move.move
    
    # if N == 0:
    #     return random_movement(BOARD)
    
    best_move = None
    moves = list(BOARD.legal_moves)

    if BOARD.turn:
        max_value = float('-inf')
        for move in moves:
            temp = deepcopy(BOARD)
            temp.push(move)

            evaluate_score = evaluate_board(temp)
            evaluate_score += evaluate_space(temp)
            evaluate_score += evaluate_center_control(temp)
            ai_piece = BOARD.piece_at(move.from_square)
            evaluate_score += evaluate_piece_safety(temp, ai_piece)

            if evaluate_score >= beta:
                return move

            alpha = max(alpha, evaluate_score)

            if evaluate_score > max_value:
                max_value = evaluate_score
                best_move = move

        return best_move
    
    else:
        min_eval = float('inf')
        for move in BOARD.legal_moves:
            temp = deepcopy(BOARD)
            temp.push(move)

            evaluate_score = evaluate_board(temp)
            evaluate_score += evaluate_space(temp)

            if evaluate_score <= alpha:
                return move

            beta = min(beta, evaluate_score)

            if evaluate_score < min_eval:
                min_eval = evaluate_score
                best_move = move

        return best_move

def min_max_algorithm(BOARD):
    max_depth = 50
    best_move = None
    alpha = float('-inf')
    beta = float('inf')

    for depth in range(1, max_depth + 1):
        current_move = min_max_movement_depth_N_alphabeta_iterative(BOARD, depth, alpha, beta)
        if current_move is not None:
            best_move = current_move
    print(best_move)
    return best_move

chess_display.chess_engine(chess_display.chess_board, min_max_algorithm, chess.BLACK)
